// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"gojeksrepo/ent/driverprofile"
	"gojeksrepo/ent/payment"
	"gojeksrepo/ent/predicate"
	"gojeksrepo/ent/trip"
	"gojeksrepo/ent/triprating"
	"gojeksrepo/ent/user"
	"gojeksrepo/ent/wallet"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDriverProfile = "DriverProfile"
	TypePayment       = "Payment"
	TypeTrip          = "Trip"
	TypeTripRating    = "TripRating"
	TypeUser          = "User"
	TypeWallet        = "Wallet"
)

// DriverProfileMutation represents an operation that mutates the DriverProfile nodes in the graph.
type DriverProfileMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	license_number      *string
	ktp_number          *string
	status              *driverprofile.Status
	vehicle_info        *string
	current_lat         *float64
	addcurrent_lat      *float64
	current_long        *float64
	addcurrent_long     *float64
	is_active           *bool
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	trips_driver        map[uuid.UUID]struct{}
	removedtrips_driver map[uuid.UUID]struct{}
	clearedtrips_driver bool
	done                bool
	oldValue            func(context.Context) (*DriverProfile, error)
	predicates          []predicate.DriverProfile
}

var _ ent.Mutation = (*DriverProfileMutation)(nil)

// driverprofileOption allows management of the mutation configuration using functional options.
type driverprofileOption func(*DriverProfileMutation)

// newDriverProfileMutation creates new mutation for the DriverProfile entity.
func newDriverProfileMutation(c config, op Op, opts ...driverprofileOption) *DriverProfileMutation {
	m := &DriverProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeDriverProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDriverProfileID sets the ID field of the mutation.
func withDriverProfileID(id uuid.UUID) driverprofileOption {
	return func(m *DriverProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *DriverProfile
		)
		m.oldValue = func(ctx context.Context) (*DriverProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DriverProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDriverProfile sets the old DriverProfile of the mutation.
func withDriverProfile(node *DriverProfile) driverprofileOption {
	return func(m *DriverProfileMutation) {
		m.oldValue = func(context.Context) (*DriverProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DriverProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DriverProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DriverProfile entities.
func (m *DriverProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DriverProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DriverProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DriverProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLicenseNumber sets the "license_number" field.
func (m *DriverProfileMutation) SetLicenseNumber(s string) {
	m.license_number = &s
}

// LicenseNumber returns the value of the "license_number" field in the mutation.
func (m *DriverProfileMutation) LicenseNumber() (r string, exists bool) {
	v := m.license_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseNumber returns the old "license_number" field's value of the DriverProfile entity.
// If the DriverProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DriverProfileMutation) OldLicenseNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseNumber: %w", err)
	}
	return oldValue.LicenseNumber, nil
}

// ResetLicenseNumber resets all changes to the "license_number" field.
func (m *DriverProfileMutation) ResetLicenseNumber() {
	m.license_number = nil
}

// SetKtpNumber sets the "ktp_number" field.
func (m *DriverProfileMutation) SetKtpNumber(s string) {
	m.ktp_number = &s
}

// KtpNumber returns the value of the "ktp_number" field in the mutation.
func (m *DriverProfileMutation) KtpNumber() (r string, exists bool) {
	v := m.ktp_number
	if v == nil {
		return
	}
	return *v, true
}

// OldKtpNumber returns the old "ktp_number" field's value of the DriverProfile entity.
// If the DriverProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DriverProfileMutation) OldKtpNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKtpNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKtpNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKtpNumber: %w", err)
	}
	return oldValue.KtpNumber, nil
}

// ResetKtpNumber resets all changes to the "ktp_number" field.
func (m *DriverProfileMutation) ResetKtpNumber() {
	m.ktp_number = nil
}

// SetStatus sets the "status" field.
func (m *DriverProfileMutation) SetStatus(d driverprofile.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DriverProfileMutation) Status() (r driverprofile.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DriverProfile entity.
// If the DriverProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DriverProfileMutation) OldStatus(ctx context.Context) (v driverprofile.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DriverProfileMutation) ResetStatus() {
	m.status = nil
}

// SetVehicleInfo sets the "vehicle_info" field.
func (m *DriverProfileMutation) SetVehicleInfo(s string) {
	m.vehicle_info = &s
}

// VehicleInfo returns the value of the "vehicle_info" field in the mutation.
func (m *DriverProfileMutation) VehicleInfo() (r string, exists bool) {
	v := m.vehicle_info
	if v == nil {
		return
	}
	return *v, true
}

// OldVehicleInfo returns the old "vehicle_info" field's value of the DriverProfile entity.
// If the DriverProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DriverProfileMutation) OldVehicleInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVehicleInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVehicleInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVehicleInfo: %w", err)
	}
	return oldValue.VehicleInfo, nil
}

// ResetVehicleInfo resets all changes to the "vehicle_info" field.
func (m *DriverProfileMutation) ResetVehicleInfo() {
	m.vehicle_info = nil
}

// SetCurrentLat sets the "current_lat" field.
func (m *DriverProfileMutation) SetCurrentLat(f float64) {
	m.current_lat = &f
	m.addcurrent_lat = nil
}

// CurrentLat returns the value of the "current_lat" field in the mutation.
func (m *DriverProfileMutation) CurrentLat() (r float64, exists bool) {
	v := m.current_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentLat returns the old "current_lat" field's value of the DriverProfile entity.
// If the DriverProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DriverProfileMutation) OldCurrentLat(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentLat: %w", err)
	}
	return oldValue.CurrentLat, nil
}

// AddCurrentLat adds f to the "current_lat" field.
func (m *DriverProfileMutation) AddCurrentLat(f float64) {
	if m.addcurrent_lat != nil {
		*m.addcurrent_lat += f
	} else {
		m.addcurrent_lat = &f
	}
}

// AddedCurrentLat returns the value that was added to the "current_lat" field in this mutation.
func (m *DriverProfileMutation) AddedCurrentLat() (r float64, exists bool) {
	v := m.addcurrent_lat
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentLat clears the value of the "current_lat" field.
func (m *DriverProfileMutation) ClearCurrentLat() {
	m.current_lat = nil
	m.addcurrent_lat = nil
	m.clearedFields[driverprofile.FieldCurrentLat] = struct{}{}
}

// CurrentLatCleared returns if the "current_lat" field was cleared in this mutation.
func (m *DriverProfileMutation) CurrentLatCleared() bool {
	_, ok := m.clearedFields[driverprofile.FieldCurrentLat]
	return ok
}

// ResetCurrentLat resets all changes to the "current_lat" field.
func (m *DriverProfileMutation) ResetCurrentLat() {
	m.current_lat = nil
	m.addcurrent_lat = nil
	delete(m.clearedFields, driverprofile.FieldCurrentLat)
}

// SetCurrentLong sets the "current_long" field.
func (m *DriverProfileMutation) SetCurrentLong(f float64) {
	m.current_long = &f
	m.addcurrent_long = nil
}

// CurrentLong returns the value of the "current_long" field in the mutation.
func (m *DriverProfileMutation) CurrentLong() (r float64, exists bool) {
	v := m.current_long
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentLong returns the old "current_long" field's value of the DriverProfile entity.
// If the DriverProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DriverProfileMutation) OldCurrentLong(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentLong: %w", err)
	}
	return oldValue.CurrentLong, nil
}

// AddCurrentLong adds f to the "current_long" field.
func (m *DriverProfileMutation) AddCurrentLong(f float64) {
	if m.addcurrent_long != nil {
		*m.addcurrent_long += f
	} else {
		m.addcurrent_long = &f
	}
}

// AddedCurrentLong returns the value that was added to the "current_long" field in this mutation.
func (m *DriverProfileMutation) AddedCurrentLong() (r float64, exists bool) {
	v := m.addcurrent_long
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentLong clears the value of the "current_long" field.
func (m *DriverProfileMutation) ClearCurrentLong() {
	m.current_long = nil
	m.addcurrent_long = nil
	m.clearedFields[driverprofile.FieldCurrentLong] = struct{}{}
}

// CurrentLongCleared returns if the "current_long" field was cleared in this mutation.
func (m *DriverProfileMutation) CurrentLongCleared() bool {
	_, ok := m.clearedFields[driverprofile.FieldCurrentLong]
	return ok
}

// ResetCurrentLong resets all changes to the "current_long" field.
func (m *DriverProfileMutation) ResetCurrentLong() {
	m.current_long = nil
	m.addcurrent_long = nil
	delete(m.clearedFields, driverprofile.FieldCurrentLong)
}

// SetIsActive sets the "is_active" field.
func (m *DriverProfileMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *DriverProfileMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the DriverProfile entity.
// If the DriverProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DriverProfileMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *DriverProfileMutation) ResetIsActive() {
	m.is_active = nil
}

// SetUserID sets the "user_id" field.
func (m *DriverProfileMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DriverProfileMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DriverProfile entity.
// If the DriverProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DriverProfileMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DriverProfileMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DriverProfileMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[driverprofile.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DriverProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DriverProfileMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DriverProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTripsDriverIDs adds the "trips_driver" edge to the Trip entity by ids.
func (m *DriverProfileMutation) AddTripsDriverIDs(ids ...uuid.UUID) {
	if m.trips_driver == nil {
		m.trips_driver = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.trips_driver[ids[i]] = struct{}{}
	}
}

// ClearTripsDriver clears the "trips_driver" edge to the Trip entity.
func (m *DriverProfileMutation) ClearTripsDriver() {
	m.clearedtrips_driver = true
}

// TripsDriverCleared reports if the "trips_driver" edge to the Trip entity was cleared.
func (m *DriverProfileMutation) TripsDriverCleared() bool {
	return m.clearedtrips_driver
}

// RemoveTripsDriverIDs removes the "trips_driver" edge to the Trip entity by IDs.
func (m *DriverProfileMutation) RemoveTripsDriverIDs(ids ...uuid.UUID) {
	if m.removedtrips_driver == nil {
		m.removedtrips_driver = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.trips_driver, ids[i])
		m.removedtrips_driver[ids[i]] = struct{}{}
	}
}

// RemovedTripsDriver returns the removed IDs of the "trips_driver" edge to the Trip entity.
func (m *DriverProfileMutation) RemovedTripsDriverIDs() (ids []uuid.UUID) {
	for id := range m.removedtrips_driver {
		ids = append(ids, id)
	}
	return
}

// TripsDriverIDs returns the "trips_driver" edge IDs in the mutation.
func (m *DriverProfileMutation) TripsDriverIDs() (ids []uuid.UUID) {
	for id := range m.trips_driver {
		ids = append(ids, id)
	}
	return
}

// ResetTripsDriver resets all changes to the "trips_driver" edge.
func (m *DriverProfileMutation) ResetTripsDriver() {
	m.trips_driver = nil
	m.clearedtrips_driver = false
	m.removedtrips_driver = nil
}

// Where appends a list predicates to the DriverProfileMutation builder.
func (m *DriverProfileMutation) Where(ps ...predicate.DriverProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DriverProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DriverProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DriverProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DriverProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DriverProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DriverProfile).
func (m *DriverProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DriverProfileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.license_number != nil {
		fields = append(fields, driverprofile.FieldLicenseNumber)
	}
	if m.ktp_number != nil {
		fields = append(fields, driverprofile.FieldKtpNumber)
	}
	if m.status != nil {
		fields = append(fields, driverprofile.FieldStatus)
	}
	if m.vehicle_info != nil {
		fields = append(fields, driverprofile.FieldVehicleInfo)
	}
	if m.current_lat != nil {
		fields = append(fields, driverprofile.FieldCurrentLat)
	}
	if m.current_long != nil {
		fields = append(fields, driverprofile.FieldCurrentLong)
	}
	if m.is_active != nil {
		fields = append(fields, driverprofile.FieldIsActive)
	}
	if m.user != nil {
		fields = append(fields, driverprofile.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DriverProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case driverprofile.FieldLicenseNumber:
		return m.LicenseNumber()
	case driverprofile.FieldKtpNumber:
		return m.KtpNumber()
	case driverprofile.FieldStatus:
		return m.Status()
	case driverprofile.FieldVehicleInfo:
		return m.VehicleInfo()
	case driverprofile.FieldCurrentLat:
		return m.CurrentLat()
	case driverprofile.FieldCurrentLong:
		return m.CurrentLong()
	case driverprofile.FieldIsActive:
		return m.IsActive()
	case driverprofile.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DriverProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case driverprofile.FieldLicenseNumber:
		return m.OldLicenseNumber(ctx)
	case driverprofile.FieldKtpNumber:
		return m.OldKtpNumber(ctx)
	case driverprofile.FieldStatus:
		return m.OldStatus(ctx)
	case driverprofile.FieldVehicleInfo:
		return m.OldVehicleInfo(ctx)
	case driverprofile.FieldCurrentLat:
		return m.OldCurrentLat(ctx)
	case driverprofile.FieldCurrentLong:
		return m.OldCurrentLong(ctx)
	case driverprofile.FieldIsActive:
		return m.OldIsActive(ctx)
	case driverprofile.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown DriverProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DriverProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case driverprofile.FieldLicenseNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseNumber(v)
		return nil
	case driverprofile.FieldKtpNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKtpNumber(v)
		return nil
	case driverprofile.FieldStatus:
		v, ok := value.(driverprofile.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case driverprofile.FieldVehicleInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVehicleInfo(v)
		return nil
	case driverprofile.FieldCurrentLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentLat(v)
		return nil
	case driverprofile.FieldCurrentLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentLong(v)
		return nil
	case driverprofile.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case driverprofile.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown DriverProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DriverProfileMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_lat != nil {
		fields = append(fields, driverprofile.FieldCurrentLat)
	}
	if m.addcurrent_long != nil {
		fields = append(fields, driverprofile.FieldCurrentLong)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DriverProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case driverprofile.FieldCurrentLat:
		return m.AddedCurrentLat()
	case driverprofile.FieldCurrentLong:
		return m.AddedCurrentLong()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DriverProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case driverprofile.FieldCurrentLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentLat(v)
		return nil
	case driverprofile.FieldCurrentLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentLong(v)
		return nil
	}
	return fmt.Errorf("unknown DriverProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DriverProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(driverprofile.FieldCurrentLat) {
		fields = append(fields, driverprofile.FieldCurrentLat)
	}
	if m.FieldCleared(driverprofile.FieldCurrentLong) {
		fields = append(fields, driverprofile.FieldCurrentLong)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DriverProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DriverProfileMutation) ClearField(name string) error {
	switch name {
	case driverprofile.FieldCurrentLat:
		m.ClearCurrentLat()
		return nil
	case driverprofile.FieldCurrentLong:
		m.ClearCurrentLong()
		return nil
	}
	return fmt.Errorf("unknown DriverProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DriverProfileMutation) ResetField(name string) error {
	switch name {
	case driverprofile.FieldLicenseNumber:
		m.ResetLicenseNumber()
		return nil
	case driverprofile.FieldKtpNumber:
		m.ResetKtpNumber()
		return nil
	case driverprofile.FieldStatus:
		m.ResetStatus()
		return nil
	case driverprofile.FieldVehicleInfo:
		m.ResetVehicleInfo()
		return nil
	case driverprofile.FieldCurrentLat:
		m.ResetCurrentLat()
		return nil
	case driverprofile.FieldCurrentLong:
		m.ResetCurrentLong()
		return nil
	case driverprofile.FieldIsActive:
		m.ResetIsActive()
		return nil
	case driverprofile.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown DriverProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DriverProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, driverprofile.EdgeUser)
	}
	if m.trips_driver != nil {
		edges = append(edges, driverprofile.EdgeTripsDriver)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DriverProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case driverprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case driverprofile.EdgeTripsDriver:
		ids := make([]ent.Value, 0, len(m.trips_driver))
		for id := range m.trips_driver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DriverProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtrips_driver != nil {
		edges = append(edges, driverprofile.EdgeTripsDriver)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DriverProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case driverprofile.EdgeTripsDriver:
		ids := make([]ent.Value, 0, len(m.removedtrips_driver))
		for id := range m.removedtrips_driver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DriverProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, driverprofile.EdgeUser)
	}
	if m.clearedtrips_driver {
		edges = append(edges, driverprofile.EdgeTripsDriver)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DriverProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case driverprofile.EdgeUser:
		return m.cleareduser
	case driverprofile.EdgeTripsDriver:
		return m.clearedtrips_driver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DriverProfileMutation) ClearEdge(name string) error {
	switch name {
	case driverprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DriverProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DriverProfileMutation) ResetEdge(name string) error {
	switch name {
	case driverprofile.EdgeUser:
		m.ResetUser()
		return nil
	case driverprofile.EdgeTripsDriver:
		m.ResetTripsDriver()
		return nil
	}
	return fmt.Errorf("unknown DriverProfile edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	payment_method *string
	amount         *float64
	addamount      *float64
	status         *payment.Status
	paid_at        *time.Time
	clearedFields  map[string]struct{}
	trip           *uuid.UUID
	clearedtrip    bool
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Payment, error)
	predicates     []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id uuid.UUID) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTripID sets the "trip_id" field.
func (m *PaymentMutation) SetTripID(u uuid.UUID) {
	m.trip = &u
}

// TripID returns the value of the "trip_id" field in the mutation.
func (m *PaymentMutation) TripID() (r uuid.UUID, exists bool) {
	v := m.trip
	if v == nil {
		return
	}
	return *v, true
}

// OldTripID returns the old "trip_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldTripID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTripID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTripID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTripID: %w", err)
	}
	return oldValue.TripID, nil
}

// ResetTripID resets all changes to the "trip_id" field.
func (m *PaymentMutation) ResetTripID() {
	m.trip = nil
}

// SetUserID sets the "user_id" field.
func (m *PaymentMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentMutation) ResetUserID() {
	m.user = nil
}

// SetPaymentMethod sets the "payment_method" field.
func (m *PaymentMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *PaymentMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPaymentMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *PaymentMutation) ResetPaymentMethod() {
	m.payment_method = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *PaymentMutation) SetStatus(pa payment.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentMutation) Status() (r payment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldStatus(ctx context.Context) (v payment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentMutation) ResetStatus() {
	m.status = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *PaymentMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *PaymentMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPaidAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *PaymentMutation) ResetPaidAt() {
	m.paid_at = nil
}

// ClearTrip clears the "trip" edge to the Trip entity.
func (m *PaymentMutation) ClearTrip() {
	m.clearedtrip = true
	m.clearedFields[payment.FieldTripID] = struct{}{}
}

// TripCleared reports if the "trip" edge to the Trip entity was cleared.
func (m *PaymentMutation) TripCleared() bool {
	return m.clearedtrip
}

// TripIDs returns the "trip" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TripID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) TripIDs() (ids []uuid.UUID) {
	if id := m.trip; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrip resets all changes to the "trip" edge.
func (m *PaymentMutation) ResetTrip() {
	m.trip = nil
	m.clearedtrip = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *PaymentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[payment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PaymentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.trip != nil {
		fields = append(fields, payment.FieldTripID)
	}
	if m.user != nil {
		fields = append(fields, payment.FieldUserID)
	}
	if m.payment_method != nil {
		fields = append(fields, payment.FieldPaymentMethod)
	}
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, payment.FieldStatus)
	}
	if m.paid_at != nil {
		fields = append(fields, payment.FieldPaidAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldTripID:
		return m.TripID()
	case payment.FieldUserID:
		return m.UserID()
	case payment.FieldPaymentMethod:
		return m.PaymentMethod()
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldStatus:
		return m.Status()
	case payment.FieldPaidAt:
		return m.PaidAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldTripID:
		return m.OldTripID(ctx)
	case payment.FieldUserID:
		return m.OldUserID(ctx)
	case payment.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldStatus:
		return m.OldStatus(ctx)
	case payment.FieldPaidAt:
		return m.OldPaidAt(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldTripID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTripID(v)
		return nil
	case payment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case payment.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldStatus:
		v, ok := value.(payment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case payment.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldTripID:
		m.ResetTripID()
		return nil
	case payment.FieldUserID:
		m.ResetUserID()
		return nil
	case payment.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldStatus:
		m.ResetStatus()
		return nil
	case payment.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.trip != nil {
		edges = append(edges, payment.EdgeTrip)
	}
	if m.user != nil {
		edges = append(edges, payment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeTrip:
		if id := m.trip; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtrip {
		edges = append(edges, payment.EdgeTrip)
	}
	if m.cleareduser {
		edges = append(edges, payment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeTrip:
		return m.clearedtrip
	case payment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeTrip:
		m.ClearTrip()
		return nil
	case payment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeTrip:
		m.ResetTrip()
		return nil
	case payment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// TripMutation represents an operation that mutates the Trip nodes in the graph.
type TripMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	pickup_lat     *float64
	addpickup_lat  *float64
	pickup_long    *float64
	addpickup_long *float64
	drop_lat       *float64
	adddrop_lat    *float64
	drop_long      *float64
	adddrop_long   *float64
	status         *trip.Status
	distance_km    *float64
	adddistance_km *float64
	numeric        *string
	is_paid        *bool
	created_at     *time.Time
	started_at     *time.Time
	completed_at   *time.Time
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	_driver        *uuid.UUID
	cleared_driver bool
	payment        map[uuid.UUID]struct{}
	removedpayment map[uuid.UUID]struct{}
	clearedpayment bool
	ratings        map[uuid.UUID]struct{}
	removedratings map[uuid.UUID]struct{}
	clearedratings bool
	done           bool
	oldValue       func(context.Context) (*Trip, error)
	predicates     []predicate.Trip
}

var _ ent.Mutation = (*TripMutation)(nil)

// tripOption allows management of the mutation configuration using functional options.
type tripOption func(*TripMutation)

// newTripMutation creates new mutation for the Trip entity.
func newTripMutation(c config, op Op, opts ...tripOption) *TripMutation {
	m := &TripMutation{
		config:        c,
		op:            op,
		typ:           TypeTrip,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTripID sets the ID field of the mutation.
func withTripID(id uuid.UUID) tripOption {
	return func(m *TripMutation) {
		var (
			err   error
			once  sync.Once
			value *Trip
		)
		m.oldValue = func(ctx context.Context) (*Trip, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trip.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrip sets the old Trip of the mutation.
func withTrip(node *Trip) tripOption {
	return func(m *TripMutation) {
		m.oldValue = func(context.Context) (*Trip, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TripMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TripMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Trip entities.
func (m *TripMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TripMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TripMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trip.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TripMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TripMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TripMutation) ResetUserID() {
	m.user = nil
}

// SetDriverID sets the "driver_id" field.
func (m *TripMutation) SetDriverID(u uuid.UUID) {
	m._driver = &u
}

// DriverID returns the value of the "driver_id" field in the mutation.
func (m *TripMutation) DriverID() (r uuid.UUID, exists bool) {
	v := m._driver
	if v == nil {
		return
	}
	return *v, true
}

// OldDriverID returns the old "driver_id" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldDriverID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDriverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDriverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDriverID: %w", err)
	}
	return oldValue.DriverID, nil
}

// ClearDriverID clears the value of the "driver_id" field.
func (m *TripMutation) ClearDriverID() {
	m._driver = nil
	m.clearedFields[trip.FieldDriverID] = struct{}{}
}

// DriverIDCleared returns if the "driver_id" field was cleared in this mutation.
func (m *TripMutation) DriverIDCleared() bool {
	_, ok := m.clearedFields[trip.FieldDriverID]
	return ok
}

// ResetDriverID resets all changes to the "driver_id" field.
func (m *TripMutation) ResetDriverID() {
	m._driver = nil
	delete(m.clearedFields, trip.FieldDriverID)
}

// SetPickupLat sets the "pickup_lat" field.
func (m *TripMutation) SetPickupLat(f float64) {
	m.pickup_lat = &f
	m.addpickup_lat = nil
}

// PickupLat returns the value of the "pickup_lat" field in the mutation.
func (m *TripMutation) PickupLat() (r float64, exists bool) {
	v := m.pickup_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldPickupLat returns the old "pickup_lat" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldPickupLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPickupLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPickupLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPickupLat: %w", err)
	}
	return oldValue.PickupLat, nil
}

// AddPickupLat adds f to the "pickup_lat" field.
func (m *TripMutation) AddPickupLat(f float64) {
	if m.addpickup_lat != nil {
		*m.addpickup_lat += f
	} else {
		m.addpickup_lat = &f
	}
}

// AddedPickupLat returns the value that was added to the "pickup_lat" field in this mutation.
func (m *TripMutation) AddedPickupLat() (r float64, exists bool) {
	v := m.addpickup_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetPickupLat resets all changes to the "pickup_lat" field.
func (m *TripMutation) ResetPickupLat() {
	m.pickup_lat = nil
	m.addpickup_lat = nil
}

// SetPickupLong sets the "pickup_long" field.
func (m *TripMutation) SetPickupLong(f float64) {
	m.pickup_long = &f
	m.addpickup_long = nil
}

// PickupLong returns the value of the "pickup_long" field in the mutation.
func (m *TripMutation) PickupLong() (r float64, exists bool) {
	v := m.pickup_long
	if v == nil {
		return
	}
	return *v, true
}

// OldPickupLong returns the old "pickup_long" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldPickupLong(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPickupLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPickupLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPickupLong: %w", err)
	}
	return oldValue.PickupLong, nil
}

// AddPickupLong adds f to the "pickup_long" field.
func (m *TripMutation) AddPickupLong(f float64) {
	if m.addpickup_long != nil {
		*m.addpickup_long += f
	} else {
		m.addpickup_long = &f
	}
}

// AddedPickupLong returns the value that was added to the "pickup_long" field in this mutation.
func (m *TripMutation) AddedPickupLong() (r float64, exists bool) {
	v := m.addpickup_long
	if v == nil {
		return
	}
	return *v, true
}

// ResetPickupLong resets all changes to the "pickup_long" field.
func (m *TripMutation) ResetPickupLong() {
	m.pickup_long = nil
	m.addpickup_long = nil
}

// SetDropLat sets the "drop_lat" field.
func (m *TripMutation) SetDropLat(f float64) {
	m.drop_lat = &f
	m.adddrop_lat = nil
}

// DropLat returns the value of the "drop_lat" field in the mutation.
func (m *TripMutation) DropLat() (r float64, exists bool) {
	v := m.drop_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldDropLat returns the old "drop_lat" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldDropLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDropLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDropLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDropLat: %w", err)
	}
	return oldValue.DropLat, nil
}

// AddDropLat adds f to the "drop_lat" field.
func (m *TripMutation) AddDropLat(f float64) {
	if m.adddrop_lat != nil {
		*m.adddrop_lat += f
	} else {
		m.adddrop_lat = &f
	}
}

// AddedDropLat returns the value that was added to the "drop_lat" field in this mutation.
func (m *TripMutation) AddedDropLat() (r float64, exists bool) {
	v := m.adddrop_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetDropLat resets all changes to the "drop_lat" field.
func (m *TripMutation) ResetDropLat() {
	m.drop_lat = nil
	m.adddrop_lat = nil
}

// SetDropLong sets the "drop_long" field.
func (m *TripMutation) SetDropLong(f float64) {
	m.drop_long = &f
	m.adddrop_long = nil
}

// DropLong returns the value of the "drop_long" field in the mutation.
func (m *TripMutation) DropLong() (r float64, exists bool) {
	v := m.drop_long
	if v == nil {
		return
	}
	return *v, true
}

// OldDropLong returns the old "drop_long" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldDropLong(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDropLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDropLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDropLong: %w", err)
	}
	return oldValue.DropLong, nil
}

// AddDropLong adds f to the "drop_long" field.
func (m *TripMutation) AddDropLong(f float64) {
	if m.adddrop_long != nil {
		*m.adddrop_long += f
	} else {
		m.adddrop_long = &f
	}
}

// AddedDropLong returns the value that was added to the "drop_long" field in this mutation.
func (m *TripMutation) AddedDropLong() (r float64, exists bool) {
	v := m.adddrop_long
	if v == nil {
		return
	}
	return *v, true
}

// ResetDropLong resets all changes to the "drop_long" field.
func (m *TripMutation) ResetDropLong() {
	m.drop_long = nil
	m.adddrop_long = nil
}

// SetStatus sets the "status" field.
func (m *TripMutation) SetStatus(t trip.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TripMutation) Status() (r trip.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldStatus(ctx context.Context) (v trip.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TripMutation) ResetStatus() {
	m.status = nil
}

// SetDistanceKm sets the "distance_km" field.
func (m *TripMutation) SetDistanceKm(f float64) {
	m.distance_km = &f
	m.adddistance_km = nil
}

// DistanceKm returns the value of the "distance_km" field in the mutation.
func (m *TripMutation) DistanceKm() (r float64, exists bool) {
	v := m.distance_km
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceKm returns the old "distance_km" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldDistanceKm(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistanceKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistanceKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceKm: %w", err)
	}
	return oldValue.DistanceKm, nil
}

// AddDistanceKm adds f to the "distance_km" field.
func (m *TripMutation) AddDistanceKm(f float64) {
	if m.adddistance_km != nil {
		*m.adddistance_km += f
	} else {
		m.adddistance_km = &f
	}
}

// AddedDistanceKm returns the value that was added to the "distance_km" field in this mutation.
func (m *TripMutation) AddedDistanceKm() (r float64, exists bool) {
	v := m.adddistance_km
	if v == nil {
		return
	}
	return *v, true
}

// ResetDistanceKm resets all changes to the "distance_km" field.
func (m *TripMutation) ResetDistanceKm() {
	m.distance_km = nil
	m.adddistance_km = nil
}

// SetNumeric sets the "numeric" field.
func (m *TripMutation) SetNumeric(s string) {
	m.numeric = &s
}

// Numeric returns the value of the "numeric" field in the mutation.
func (m *TripMutation) Numeric() (r string, exists bool) {
	v := m.numeric
	if v == nil {
		return
	}
	return *v, true
}

// OldNumeric returns the old "numeric" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldNumeric(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumeric is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumeric requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumeric: %w", err)
	}
	return oldValue.Numeric, nil
}

// ResetNumeric resets all changes to the "numeric" field.
func (m *TripMutation) ResetNumeric() {
	m.numeric = nil
}

// SetIsPaid sets the "is_paid" field.
func (m *TripMutation) SetIsPaid(b bool) {
	m.is_paid = &b
}

// IsPaid returns the value of the "is_paid" field in the mutation.
func (m *TripMutation) IsPaid() (r bool, exists bool) {
	v := m.is_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPaid returns the old "is_paid" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldIsPaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPaid: %w", err)
	}
	return oldValue.IsPaid, nil
}

// ResetIsPaid resets all changes to the "is_paid" field.
func (m *TripMutation) ResetIsPaid() {
	m.is_paid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TripMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TripMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TripMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStartedAt sets the "started_at" field.
func (m *TripMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *TripMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *TripMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *TripMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *TripMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *TripMutation) ResetCompletedAt() {
	m.completed_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TripMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[trip.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TripMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TripMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TripMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDriver clears the "driver" edge to the DriverProfile entity.
func (m *TripMutation) ClearDriver() {
	m.cleared_driver = true
	m.clearedFields[trip.FieldDriverID] = struct{}{}
}

// DriverCleared reports if the "driver" edge to the DriverProfile entity was cleared.
func (m *TripMutation) DriverCleared() bool {
	return m.DriverIDCleared() || m.cleared_driver
}

// DriverIDs returns the "driver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DriverID instead. It exists only for internal usage by the builders.
func (m *TripMutation) DriverIDs() (ids []uuid.UUID) {
	if id := m._driver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDriver resets all changes to the "driver" edge.
func (m *TripMutation) ResetDriver() {
	m._driver = nil
	m.cleared_driver = false
}

// AddPaymentIDs adds the "payment" edge to the Payment entity by ids.
func (m *TripMutation) AddPaymentIDs(ids ...uuid.UUID) {
	if m.payment == nil {
		m.payment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *TripMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *TripMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// RemovePaymentIDs removes the "payment" edge to the Payment entity by IDs.
func (m *TripMutation) RemovePaymentIDs(ids ...uuid.UUID) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payment, ids[i])
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed IDs of the "payment" edge to the Payment entity.
func (m *TripMutation) RemovedPaymentIDs() (ids []uuid.UUID) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
func (m *TripMutation) PaymentIDs() (ids []uuid.UUID) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *TripMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
	m.removedpayment = nil
}

// AddRatingIDs adds the "ratings" edge to the TripRating entity by ids.
func (m *TripMutation) AddRatingIDs(ids ...uuid.UUID) {
	if m.ratings == nil {
		m.ratings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ratings[ids[i]] = struct{}{}
	}
}

// ClearRatings clears the "ratings" edge to the TripRating entity.
func (m *TripMutation) ClearRatings() {
	m.clearedratings = true
}

// RatingsCleared reports if the "ratings" edge to the TripRating entity was cleared.
func (m *TripMutation) RatingsCleared() bool {
	return m.clearedratings
}

// RemoveRatingIDs removes the "ratings" edge to the TripRating entity by IDs.
func (m *TripMutation) RemoveRatingIDs(ids ...uuid.UUID) {
	if m.removedratings == nil {
		m.removedratings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ratings, ids[i])
		m.removedratings[ids[i]] = struct{}{}
	}
}

// RemovedRatings returns the removed IDs of the "ratings" edge to the TripRating entity.
func (m *TripMutation) RemovedRatingsIDs() (ids []uuid.UUID) {
	for id := range m.removedratings {
		ids = append(ids, id)
	}
	return
}

// RatingsIDs returns the "ratings" edge IDs in the mutation.
func (m *TripMutation) RatingsIDs() (ids []uuid.UUID) {
	for id := range m.ratings {
		ids = append(ids, id)
	}
	return
}

// ResetRatings resets all changes to the "ratings" edge.
func (m *TripMutation) ResetRatings() {
	m.ratings = nil
	m.clearedratings = false
	m.removedratings = nil
}

// Where appends a list predicates to the TripMutation builder.
func (m *TripMutation) Where(ps ...predicate.Trip) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TripMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TripMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trip, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TripMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TripMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trip).
func (m *TripMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TripMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, trip.FieldUserID)
	}
	if m._driver != nil {
		fields = append(fields, trip.FieldDriverID)
	}
	if m.pickup_lat != nil {
		fields = append(fields, trip.FieldPickupLat)
	}
	if m.pickup_long != nil {
		fields = append(fields, trip.FieldPickupLong)
	}
	if m.drop_lat != nil {
		fields = append(fields, trip.FieldDropLat)
	}
	if m.drop_long != nil {
		fields = append(fields, trip.FieldDropLong)
	}
	if m.status != nil {
		fields = append(fields, trip.FieldStatus)
	}
	if m.distance_km != nil {
		fields = append(fields, trip.FieldDistanceKm)
	}
	if m.numeric != nil {
		fields = append(fields, trip.FieldNumeric)
	}
	if m.is_paid != nil {
		fields = append(fields, trip.FieldIsPaid)
	}
	if m.created_at != nil {
		fields = append(fields, trip.FieldCreatedAt)
	}
	if m.started_at != nil {
		fields = append(fields, trip.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, trip.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TripMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trip.FieldUserID:
		return m.UserID()
	case trip.FieldDriverID:
		return m.DriverID()
	case trip.FieldPickupLat:
		return m.PickupLat()
	case trip.FieldPickupLong:
		return m.PickupLong()
	case trip.FieldDropLat:
		return m.DropLat()
	case trip.FieldDropLong:
		return m.DropLong()
	case trip.FieldStatus:
		return m.Status()
	case trip.FieldDistanceKm:
		return m.DistanceKm()
	case trip.FieldNumeric:
		return m.Numeric()
	case trip.FieldIsPaid:
		return m.IsPaid()
	case trip.FieldCreatedAt:
		return m.CreatedAt()
	case trip.FieldStartedAt:
		return m.StartedAt()
	case trip.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TripMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trip.FieldUserID:
		return m.OldUserID(ctx)
	case trip.FieldDriverID:
		return m.OldDriverID(ctx)
	case trip.FieldPickupLat:
		return m.OldPickupLat(ctx)
	case trip.FieldPickupLong:
		return m.OldPickupLong(ctx)
	case trip.FieldDropLat:
		return m.OldDropLat(ctx)
	case trip.FieldDropLong:
		return m.OldDropLong(ctx)
	case trip.FieldStatus:
		return m.OldStatus(ctx)
	case trip.FieldDistanceKm:
		return m.OldDistanceKm(ctx)
	case trip.FieldNumeric:
		return m.OldNumeric(ctx)
	case trip.FieldIsPaid:
		return m.OldIsPaid(ctx)
	case trip.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trip.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case trip.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Trip field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TripMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trip.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case trip.FieldDriverID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDriverID(v)
		return nil
	case trip.FieldPickupLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPickupLat(v)
		return nil
	case trip.FieldPickupLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPickupLong(v)
		return nil
	case trip.FieldDropLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDropLat(v)
		return nil
	case trip.FieldDropLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDropLong(v)
		return nil
	case trip.FieldStatus:
		v, ok := value.(trip.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case trip.FieldDistanceKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceKm(v)
		return nil
	case trip.FieldNumeric:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumeric(v)
		return nil
	case trip.FieldIsPaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPaid(v)
		return nil
	case trip.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trip.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case trip.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Trip field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TripMutation) AddedFields() []string {
	var fields []string
	if m.addpickup_lat != nil {
		fields = append(fields, trip.FieldPickupLat)
	}
	if m.addpickup_long != nil {
		fields = append(fields, trip.FieldPickupLong)
	}
	if m.adddrop_lat != nil {
		fields = append(fields, trip.FieldDropLat)
	}
	if m.adddrop_long != nil {
		fields = append(fields, trip.FieldDropLong)
	}
	if m.adddistance_km != nil {
		fields = append(fields, trip.FieldDistanceKm)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TripMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trip.FieldPickupLat:
		return m.AddedPickupLat()
	case trip.FieldPickupLong:
		return m.AddedPickupLong()
	case trip.FieldDropLat:
		return m.AddedDropLat()
	case trip.FieldDropLong:
		return m.AddedDropLong()
	case trip.FieldDistanceKm:
		return m.AddedDistanceKm()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TripMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trip.FieldPickupLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPickupLat(v)
		return nil
	case trip.FieldPickupLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPickupLong(v)
		return nil
	case trip.FieldDropLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDropLat(v)
		return nil
	case trip.FieldDropLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDropLong(v)
		return nil
	case trip.FieldDistanceKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistanceKm(v)
		return nil
	}
	return fmt.Errorf("unknown Trip numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TripMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trip.FieldDriverID) {
		fields = append(fields, trip.FieldDriverID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TripMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TripMutation) ClearField(name string) error {
	switch name {
	case trip.FieldDriverID:
		m.ClearDriverID()
		return nil
	}
	return fmt.Errorf("unknown Trip nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TripMutation) ResetField(name string) error {
	switch name {
	case trip.FieldUserID:
		m.ResetUserID()
		return nil
	case trip.FieldDriverID:
		m.ResetDriverID()
		return nil
	case trip.FieldPickupLat:
		m.ResetPickupLat()
		return nil
	case trip.FieldPickupLong:
		m.ResetPickupLong()
		return nil
	case trip.FieldDropLat:
		m.ResetDropLat()
		return nil
	case trip.FieldDropLong:
		m.ResetDropLong()
		return nil
	case trip.FieldStatus:
		m.ResetStatus()
		return nil
	case trip.FieldDistanceKm:
		m.ResetDistanceKm()
		return nil
	case trip.FieldNumeric:
		m.ResetNumeric()
		return nil
	case trip.FieldIsPaid:
		m.ResetIsPaid()
		return nil
	case trip.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trip.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case trip.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Trip field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TripMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, trip.EdgeUser)
	}
	if m._driver != nil {
		edges = append(edges, trip.EdgeDriver)
	}
	if m.payment != nil {
		edges = append(edges, trip.EdgePayment)
	}
	if m.ratings != nil {
		edges = append(edges, trip.EdgeRatings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TripMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trip.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case trip.EdgeDriver:
		if id := m._driver; id != nil {
			return []ent.Value{*id}
		}
	case trip.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	case trip.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.ratings))
		for id := range m.ratings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TripMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpayment != nil {
		edges = append(edges, trip.EdgePayment)
	}
	if m.removedratings != nil {
		edges = append(edges, trip.EdgeRatings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TripMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trip.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	case trip.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.removedratings))
		for id := range m.removedratings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TripMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, trip.EdgeUser)
	}
	if m.cleared_driver {
		edges = append(edges, trip.EdgeDriver)
	}
	if m.clearedpayment {
		edges = append(edges, trip.EdgePayment)
	}
	if m.clearedratings {
		edges = append(edges, trip.EdgeRatings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TripMutation) EdgeCleared(name string) bool {
	switch name {
	case trip.EdgeUser:
		return m.cleareduser
	case trip.EdgeDriver:
		return m.cleared_driver
	case trip.EdgePayment:
		return m.clearedpayment
	case trip.EdgeRatings:
		return m.clearedratings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TripMutation) ClearEdge(name string) error {
	switch name {
	case trip.EdgeUser:
		m.ClearUser()
		return nil
	case trip.EdgeDriver:
		m.ClearDriver()
		return nil
	}
	return fmt.Errorf("unknown Trip unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TripMutation) ResetEdge(name string) error {
	switch name {
	case trip.EdgeUser:
		m.ResetUser()
		return nil
	case trip.EdgeDriver:
		m.ResetDriver()
		return nil
	case trip.EdgePayment:
		m.ResetPayment()
		return nil
	case trip.EdgeRatings:
		m.ResetRatings()
		return nil
	}
	return fmt.Errorf("unknown Trip edge %s", name)
}

// TripRatingMutation represents an operation that mutates the TripRating nodes in the graph.
type TripRatingMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	rating           *int
	addrating        *int
	comment          *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	trip             *uuid.UUID
	clearedtrip      bool
	from_user        *uuid.UUID
	clearedfrom_user bool
	to_user          *uuid.UUID
	clearedto_user   bool
	done             bool
	oldValue         func(context.Context) (*TripRating, error)
	predicates       []predicate.TripRating
}

var _ ent.Mutation = (*TripRatingMutation)(nil)

// tripratingOption allows management of the mutation configuration using functional options.
type tripratingOption func(*TripRatingMutation)

// newTripRatingMutation creates new mutation for the TripRating entity.
func newTripRatingMutation(c config, op Op, opts ...tripratingOption) *TripRatingMutation {
	m := &TripRatingMutation{
		config:        c,
		op:            op,
		typ:           TypeTripRating,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTripRatingID sets the ID field of the mutation.
func withTripRatingID(id uuid.UUID) tripratingOption {
	return func(m *TripRatingMutation) {
		var (
			err   error
			once  sync.Once
			value *TripRating
		)
		m.oldValue = func(ctx context.Context) (*TripRating, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TripRating.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTripRating sets the old TripRating of the mutation.
func withTripRating(node *TripRating) tripratingOption {
	return func(m *TripRatingMutation) {
		m.oldValue = func(context.Context) (*TripRating, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TripRatingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TripRatingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TripRating entities.
func (m *TripRatingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TripRatingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TripRatingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TripRating.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTripID sets the "trip_id" field.
func (m *TripRatingMutation) SetTripID(u uuid.UUID) {
	m.trip = &u
}

// TripID returns the value of the "trip_id" field in the mutation.
func (m *TripRatingMutation) TripID() (r uuid.UUID, exists bool) {
	v := m.trip
	if v == nil {
		return
	}
	return *v, true
}

// OldTripID returns the old "trip_id" field's value of the TripRating entity.
// If the TripRating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripRatingMutation) OldTripID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTripID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTripID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTripID: %w", err)
	}
	return oldValue.TripID, nil
}

// ResetTripID resets all changes to the "trip_id" field.
func (m *TripRatingMutation) ResetTripID() {
	m.trip = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *TripRatingMutation) SetFromUserID(u uuid.UUID) {
	m.from_user = &u
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *TripRatingMutation) FromUserID() (r uuid.UUID, exists bool) {
	v := m.from_user
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the TripRating entity.
// If the TripRating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripRatingMutation) OldFromUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *TripRatingMutation) ResetFromUserID() {
	m.from_user = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *TripRatingMutation) SetToUserID(u uuid.UUID) {
	m.to_user = &u
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *TripRatingMutation) ToUserID() (r uuid.UUID, exists bool) {
	v := m.to_user
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the TripRating entity.
// If the TripRating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripRatingMutation) OldToUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *TripRatingMutation) ResetToUserID() {
	m.to_user = nil
}

// SetRating sets the "rating" field.
func (m *TripRatingMutation) SetRating(i int) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *TripRatingMutation) Rating() (r int, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the TripRating entity.
// If the TripRating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripRatingMutation) OldRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *TripRatingMutation) AddRating(i int) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *TripRatingMutation) AddedRating() (r int, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *TripRatingMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetComment sets the "comment" field.
func (m *TripRatingMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *TripRatingMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the TripRating entity.
// If the TripRating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripRatingMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *TripRatingMutation) ResetComment() {
	m.comment = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TripRatingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TripRatingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TripRating entity.
// If the TripRating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripRatingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TripRatingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTrip clears the "trip" edge to the Trip entity.
func (m *TripRatingMutation) ClearTrip() {
	m.clearedtrip = true
	m.clearedFields[triprating.FieldTripID] = struct{}{}
}

// TripCleared reports if the "trip" edge to the Trip entity was cleared.
func (m *TripRatingMutation) TripCleared() bool {
	return m.clearedtrip
}

// TripIDs returns the "trip" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TripID instead. It exists only for internal usage by the builders.
func (m *TripRatingMutation) TripIDs() (ids []uuid.UUID) {
	if id := m.trip; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrip resets all changes to the "trip" edge.
func (m *TripRatingMutation) ResetTrip() {
	m.trip = nil
	m.clearedtrip = false
}

// ClearFromUser clears the "from_user" edge to the User entity.
func (m *TripRatingMutation) ClearFromUser() {
	m.clearedfrom_user = true
	m.clearedFields[triprating.FieldFromUserID] = struct{}{}
}

// FromUserCleared reports if the "from_user" edge to the User entity was cleared.
func (m *TripRatingMutation) FromUserCleared() bool {
	return m.clearedfrom_user
}

// FromUserIDs returns the "from_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromUserID instead. It exists only for internal usage by the builders.
func (m *TripRatingMutation) FromUserIDs() (ids []uuid.UUID) {
	if id := m.from_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromUser resets all changes to the "from_user" edge.
func (m *TripRatingMutation) ResetFromUser() {
	m.from_user = nil
	m.clearedfrom_user = false
}

// ClearToUser clears the "to_user" edge to the User entity.
func (m *TripRatingMutation) ClearToUser() {
	m.clearedto_user = true
	m.clearedFields[triprating.FieldToUserID] = struct{}{}
}

// ToUserCleared reports if the "to_user" edge to the User entity was cleared.
func (m *TripRatingMutation) ToUserCleared() bool {
	return m.clearedto_user
}

// ToUserIDs returns the "to_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToUserID instead. It exists only for internal usage by the builders.
func (m *TripRatingMutation) ToUserIDs() (ids []uuid.UUID) {
	if id := m.to_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToUser resets all changes to the "to_user" edge.
func (m *TripRatingMutation) ResetToUser() {
	m.to_user = nil
	m.clearedto_user = false
}

// Where appends a list predicates to the TripRatingMutation builder.
func (m *TripRatingMutation) Where(ps ...predicate.TripRating) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TripRatingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TripRatingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TripRating, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TripRatingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TripRatingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TripRating).
func (m *TripRatingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TripRatingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.trip != nil {
		fields = append(fields, triprating.FieldTripID)
	}
	if m.from_user != nil {
		fields = append(fields, triprating.FieldFromUserID)
	}
	if m.to_user != nil {
		fields = append(fields, triprating.FieldToUserID)
	}
	if m.rating != nil {
		fields = append(fields, triprating.FieldRating)
	}
	if m.comment != nil {
		fields = append(fields, triprating.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, triprating.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TripRatingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case triprating.FieldTripID:
		return m.TripID()
	case triprating.FieldFromUserID:
		return m.FromUserID()
	case triprating.FieldToUserID:
		return m.ToUserID()
	case triprating.FieldRating:
		return m.Rating()
	case triprating.FieldComment:
		return m.Comment()
	case triprating.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TripRatingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case triprating.FieldTripID:
		return m.OldTripID(ctx)
	case triprating.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case triprating.FieldToUserID:
		return m.OldToUserID(ctx)
	case triprating.FieldRating:
		return m.OldRating(ctx)
	case triprating.FieldComment:
		return m.OldComment(ctx)
	case triprating.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TripRating field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TripRatingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case triprating.FieldTripID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTripID(v)
		return nil
	case triprating.FieldFromUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case triprating.FieldToUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case triprating.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case triprating.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case triprating.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TripRating field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TripRatingMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, triprating.FieldRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TripRatingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case triprating.FieldRating:
		return m.AddedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TripRatingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case triprating.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	}
	return fmt.Errorf("unknown TripRating numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TripRatingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TripRatingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TripRatingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TripRating nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TripRatingMutation) ResetField(name string) error {
	switch name {
	case triprating.FieldTripID:
		m.ResetTripID()
		return nil
	case triprating.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case triprating.FieldToUserID:
		m.ResetToUserID()
		return nil
	case triprating.FieldRating:
		m.ResetRating()
		return nil
	case triprating.FieldComment:
		m.ResetComment()
		return nil
	case triprating.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown TripRating field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TripRatingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.trip != nil {
		edges = append(edges, triprating.EdgeTrip)
	}
	if m.from_user != nil {
		edges = append(edges, triprating.EdgeFromUser)
	}
	if m.to_user != nil {
		edges = append(edges, triprating.EdgeToUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TripRatingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case triprating.EdgeTrip:
		if id := m.trip; id != nil {
			return []ent.Value{*id}
		}
	case triprating.EdgeFromUser:
		if id := m.from_user; id != nil {
			return []ent.Value{*id}
		}
	case triprating.EdgeToUser:
		if id := m.to_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TripRatingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TripRatingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TripRatingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtrip {
		edges = append(edges, triprating.EdgeTrip)
	}
	if m.clearedfrom_user {
		edges = append(edges, triprating.EdgeFromUser)
	}
	if m.clearedto_user {
		edges = append(edges, triprating.EdgeToUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TripRatingMutation) EdgeCleared(name string) bool {
	switch name {
	case triprating.EdgeTrip:
		return m.clearedtrip
	case triprating.EdgeFromUser:
		return m.clearedfrom_user
	case triprating.EdgeToUser:
		return m.clearedto_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TripRatingMutation) ClearEdge(name string) error {
	switch name {
	case triprating.EdgeTrip:
		m.ClearTrip()
		return nil
	case triprating.EdgeFromUser:
		m.ClearFromUser()
		return nil
	case triprating.EdgeToUser:
		m.ClearToUser()
		return nil
	}
	return fmt.Errorf("unknown TripRating unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TripRatingMutation) ResetEdge(name string) error {
	switch name {
	case triprating.EdgeTrip:
		m.ResetTrip()
		return nil
	case triprating.EdgeFromUser:
		m.ResetFromUser()
		return nil
	case triprating.EdgeToUser:
		m.ResetToUser()
		return nil
	}
	return fmt.Errorf("unknown TripRating edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	name                    *string
	email                   *string
	phone                   *string
	password                *string
	role                    *user.Role
	is_verified             *bool
	created_at              *time.Time
	clearedFields           map[string]struct{}
	user_trips              map[uuid.UUID]struct{}
	removeduser_trips       map[uuid.UUID]struct{}
	cleareduser_trips       bool
	payments                map[uuid.UUID]struct{}
	removedpayments         map[uuid.UUID]struct{}
	clearedpayments         bool
	user_balance            map[uuid.UUID]struct{}
	removeduser_balance     map[uuid.UUID]struct{}
	cleareduser_balance     bool
	given_ratings           map[uuid.UUID]struct{}
	removedgiven_ratings    map[uuid.UUID]struct{}
	clearedgiven_ratings    bool
	received_ratings        map[uuid.UUID]struct{}
	removedreceived_ratings map[uuid.UUID]struct{}
	clearedreceived_ratings bool
	user_driver             map[uuid.UUID]struct{}
	removeduser_driver      map[uuid.UUID]struct{}
	cleareduser_driver      bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *UserMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUserTripIDs adds the "user_trips" edge to the Trip entity by ids.
func (m *UserMutation) AddUserTripIDs(ids ...uuid.UUID) {
	if m.user_trips == nil {
		m.user_trips = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_trips[ids[i]] = struct{}{}
	}
}

// ClearUserTrips clears the "user_trips" edge to the Trip entity.
func (m *UserMutation) ClearUserTrips() {
	m.cleareduser_trips = true
}

// UserTripsCleared reports if the "user_trips" edge to the Trip entity was cleared.
func (m *UserMutation) UserTripsCleared() bool {
	return m.cleareduser_trips
}

// RemoveUserTripIDs removes the "user_trips" edge to the Trip entity by IDs.
func (m *UserMutation) RemoveUserTripIDs(ids ...uuid.UUID) {
	if m.removeduser_trips == nil {
		m.removeduser_trips = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_trips, ids[i])
		m.removeduser_trips[ids[i]] = struct{}{}
	}
}

// RemovedUserTrips returns the removed IDs of the "user_trips" edge to the Trip entity.
func (m *UserMutation) RemovedUserTripsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_trips {
		ids = append(ids, id)
	}
	return
}

// UserTripsIDs returns the "user_trips" edge IDs in the mutation.
func (m *UserMutation) UserTripsIDs() (ids []uuid.UUID) {
	for id := range m.user_trips {
		ids = append(ids, id)
	}
	return
}

// ResetUserTrips resets all changes to the "user_trips" edge.
func (m *UserMutation) ResetUserTrips() {
	m.user_trips = nil
	m.cleareduser_trips = false
	m.removeduser_trips = nil
}

// AddPaymentIDs adds the "payments" edge to the Payment entity by ids.
func (m *UserMutation) AddPaymentIDs(ids ...uuid.UUID) {
	if m.payments == nil {
		m.payments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the Payment entity.
func (m *UserMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the Payment entity was cleared.
func (m *UserMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the Payment entity by IDs.
func (m *UserMutation) RemovePaymentIDs(ids ...uuid.UUID) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the Payment entity.
func (m *UserMutation) RemovedPaymentsIDs() (ids []uuid.UUID) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *UserMutation) PaymentsIDs() (ids []uuid.UUID) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *UserMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// AddUserBalanceIDs adds the "user_balance" edge to the Wallet entity by ids.
func (m *UserMutation) AddUserBalanceIDs(ids ...uuid.UUID) {
	if m.user_balance == nil {
		m.user_balance = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_balance[ids[i]] = struct{}{}
	}
}

// ClearUserBalance clears the "user_balance" edge to the Wallet entity.
func (m *UserMutation) ClearUserBalance() {
	m.cleareduser_balance = true
}

// UserBalanceCleared reports if the "user_balance" edge to the Wallet entity was cleared.
func (m *UserMutation) UserBalanceCleared() bool {
	return m.cleareduser_balance
}

// RemoveUserBalanceIDs removes the "user_balance" edge to the Wallet entity by IDs.
func (m *UserMutation) RemoveUserBalanceIDs(ids ...uuid.UUID) {
	if m.removeduser_balance == nil {
		m.removeduser_balance = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_balance, ids[i])
		m.removeduser_balance[ids[i]] = struct{}{}
	}
}

// RemovedUserBalance returns the removed IDs of the "user_balance" edge to the Wallet entity.
func (m *UserMutation) RemovedUserBalanceIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_balance {
		ids = append(ids, id)
	}
	return
}

// UserBalanceIDs returns the "user_balance" edge IDs in the mutation.
func (m *UserMutation) UserBalanceIDs() (ids []uuid.UUID) {
	for id := range m.user_balance {
		ids = append(ids, id)
	}
	return
}

// ResetUserBalance resets all changes to the "user_balance" edge.
func (m *UserMutation) ResetUserBalance() {
	m.user_balance = nil
	m.cleareduser_balance = false
	m.removeduser_balance = nil
}

// AddGivenRatingIDs adds the "given_ratings" edge to the TripRating entity by ids.
func (m *UserMutation) AddGivenRatingIDs(ids ...uuid.UUID) {
	if m.given_ratings == nil {
		m.given_ratings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.given_ratings[ids[i]] = struct{}{}
	}
}

// ClearGivenRatings clears the "given_ratings" edge to the TripRating entity.
func (m *UserMutation) ClearGivenRatings() {
	m.clearedgiven_ratings = true
}

// GivenRatingsCleared reports if the "given_ratings" edge to the TripRating entity was cleared.
func (m *UserMutation) GivenRatingsCleared() bool {
	return m.clearedgiven_ratings
}

// RemoveGivenRatingIDs removes the "given_ratings" edge to the TripRating entity by IDs.
func (m *UserMutation) RemoveGivenRatingIDs(ids ...uuid.UUID) {
	if m.removedgiven_ratings == nil {
		m.removedgiven_ratings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.given_ratings, ids[i])
		m.removedgiven_ratings[ids[i]] = struct{}{}
	}
}

// RemovedGivenRatings returns the removed IDs of the "given_ratings" edge to the TripRating entity.
func (m *UserMutation) RemovedGivenRatingsIDs() (ids []uuid.UUID) {
	for id := range m.removedgiven_ratings {
		ids = append(ids, id)
	}
	return
}

// GivenRatingsIDs returns the "given_ratings" edge IDs in the mutation.
func (m *UserMutation) GivenRatingsIDs() (ids []uuid.UUID) {
	for id := range m.given_ratings {
		ids = append(ids, id)
	}
	return
}

// ResetGivenRatings resets all changes to the "given_ratings" edge.
func (m *UserMutation) ResetGivenRatings() {
	m.given_ratings = nil
	m.clearedgiven_ratings = false
	m.removedgiven_ratings = nil
}

// AddReceivedRatingIDs adds the "received_ratings" edge to the TripRating entity by ids.
func (m *UserMutation) AddReceivedRatingIDs(ids ...uuid.UUID) {
	if m.received_ratings == nil {
		m.received_ratings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.received_ratings[ids[i]] = struct{}{}
	}
}

// ClearReceivedRatings clears the "received_ratings" edge to the TripRating entity.
func (m *UserMutation) ClearReceivedRatings() {
	m.clearedreceived_ratings = true
}

// ReceivedRatingsCleared reports if the "received_ratings" edge to the TripRating entity was cleared.
func (m *UserMutation) ReceivedRatingsCleared() bool {
	return m.clearedreceived_ratings
}

// RemoveReceivedRatingIDs removes the "received_ratings" edge to the TripRating entity by IDs.
func (m *UserMutation) RemoveReceivedRatingIDs(ids ...uuid.UUID) {
	if m.removedreceived_ratings == nil {
		m.removedreceived_ratings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.received_ratings, ids[i])
		m.removedreceived_ratings[ids[i]] = struct{}{}
	}
}

// RemovedReceivedRatings returns the removed IDs of the "received_ratings" edge to the TripRating entity.
func (m *UserMutation) RemovedReceivedRatingsIDs() (ids []uuid.UUID) {
	for id := range m.removedreceived_ratings {
		ids = append(ids, id)
	}
	return
}

// ReceivedRatingsIDs returns the "received_ratings" edge IDs in the mutation.
func (m *UserMutation) ReceivedRatingsIDs() (ids []uuid.UUID) {
	for id := range m.received_ratings {
		ids = append(ids, id)
	}
	return
}

// ResetReceivedRatings resets all changes to the "received_ratings" edge.
func (m *UserMutation) ResetReceivedRatings() {
	m.received_ratings = nil
	m.clearedreceived_ratings = false
	m.removedreceived_ratings = nil
}

// AddUserDriverIDs adds the "user_driver" edge to the DriverProfile entity by ids.
func (m *UserMutation) AddUserDriverIDs(ids ...uuid.UUID) {
	if m.user_driver == nil {
		m.user_driver = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_driver[ids[i]] = struct{}{}
	}
}

// ClearUserDriver clears the "user_driver" edge to the DriverProfile entity.
func (m *UserMutation) ClearUserDriver() {
	m.cleareduser_driver = true
}

// UserDriverCleared reports if the "user_driver" edge to the DriverProfile entity was cleared.
func (m *UserMutation) UserDriverCleared() bool {
	return m.cleareduser_driver
}

// RemoveUserDriverIDs removes the "user_driver" edge to the DriverProfile entity by IDs.
func (m *UserMutation) RemoveUserDriverIDs(ids ...uuid.UUID) {
	if m.removeduser_driver == nil {
		m.removeduser_driver = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_driver, ids[i])
		m.removeduser_driver[ids[i]] = struct{}{}
	}
}

// RemovedUserDriver returns the removed IDs of the "user_driver" edge to the DriverProfile entity.
func (m *UserMutation) RemovedUserDriverIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_driver {
		ids = append(ids, id)
	}
	return
}

// UserDriverIDs returns the "user_driver" edge IDs in the mutation.
func (m *UserMutation) UserDriverIDs() (ids []uuid.UUID) {
	for id := range m.user_driver {
		ids = append(ids, id)
	}
	return
}

// ResetUserDriver resets all changes to the "user_driver" edge.
func (m *UserMutation) ResetUserDriver() {
	m.user_driver = nil
	m.cleareduser_driver = false
	m.removeduser_driver = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.is_verified != nil {
		fields = append(fields, user.FieldIsVerified)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRole:
		return m.Role()
	case user.FieldIsVerified:
		return m.IsVerified()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.user_trips != nil {
		edges = append(edges, user.EdgeUserTrips)
	}
	if m.payments != nil {
		edges = append(edges, user.EdgePayments)
	}
	if m.user_balance != nil {
		edges = append(edges, user.EdgeUserBalance)
	}
	if m.given_ratings != nil {
		edges = append(edges, user.EdgeGivenRatings)
	}
	if m.received_ratings != nil {
		edges = append(edges, user.EdgeReceivedRatings)
	}
	if m.user_driver != nil {
		edges = append(edges, user.EdgeUserDriver)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserTrips:
		ids := make([]ent.Value, 0, len(m.user_trips))
		for id := range m.user_trips {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserBalance:
		ids := make([]ent.Value, 0, len(m.user_balance))
		for id := range m.user_balance {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGivenRatings:
		ids := make([]ent.Value, 0, len(m.given_ratings))
		for id := range m.given_ratings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedRatings:
		ids := make([]ent.Value, 0, len(m.received_ratings))
		for id := range m.received_ratings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDriver:
		ids := make([]ent.Value, 0, len(m.user_driver))
		for id := range m.user_driver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removeduser_trips != nil {
		edges = append(edges, user.EdgeUserTrips)
	}
	if m.removedpayments != nil {
		edges = append(edges, user.EdgePayments)
	}
	if m.removeduser_balance != nil {
		edges = append(edges, user.EdgeUserBalance)
	}
	if m.removedgiven_ratings != nil {
		edges = append(edges, user.EdgeGivenRatings)
	}
	if m.removedreceived_ratings != nil {
		edges = append(edges, user.EdgeReceivedRatings)
	}
	if m.removeduser_driver != nil {
		edges = append(edges, user.EdgeUserDriver)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserTrips:
		ids := make([]ent.Value, 0, len(m.removeduser_trips))
		for id := range m.removeduser_trips {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserBalance:
		ids := make([]ent.Value, 0, len(m.removeduser_balance))
		for id := range m.removeduser_balance {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGivenRatings:
		ids := make([]ent.Value, 0, len(m.removedgiven_ratings))
		for id := range m.removedgiven_ratings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedRatings:
		ids := make([]ent.Value, 0, len(m.removedreceived_ratings))
		for id := range m.removedreceived_ratings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDriver:
		ids := make([]ent.Value, 0, len(m.removeduser_driver))
		for id := range m.removeduser_driver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareduser_trips {
		edges = append(edges, user.EdgeUserTrips)
	}
	if m.clearedpayments {
		edges = append(edges, user.EdgePayments)
	}
	if m.cleareduser_balance {
		edges = append(edges, user.EdgeUserBalance)
	}
	if m.clearedgiven_ratings {
		edges = append(edges, user.EdgeGivenRatings)
	}
	if m.clearedreceived_ratings {
		edges = append(edges, user.EdgeReceivedRatings)
	}
	if m.cleareduser_driver {
		edges = append(edges, user.EdgeUserDriver)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserTrips:
		return m.cleareduser_trips
	case user.EdgePayments:
		return m.clearedpayments
	case user.EdgeUserBalance:
		return m.cleareduser_balance
	case user.EdgeGivenRatings:
		return m.clearedgiven_ratings
	case user.EdgeReceivedRatings:
		return m.clearedreceived_ratings
	case user.EdgeUserDriver:
		return m.cleareduser_driver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserTrips:
		m.ResetUserTrips()
		return nil
	case user.EdgePayments:
		m.ResetPayments()
		return nil
	case user.EdgeUserBalance:
		m.ResetUserBalance()
		return nil
	case user.EdgeGivenRatings:
		m.ResetGivenRatings()
		return nil
	case user.EdgeReceivedRatings:
		m.ResetReceivedRatings()
		return nil
	case user.EdgeUserDriver:
		m.ResetUserDriver()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	balance       *float64
	addbalance    *float64
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Wallet, error)
	predicates    []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id uuid.UUID) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wallet entities.
func (m *WalletMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *WalletMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WalletMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WalletMutation) ResetUserID() {
	m.user = nil
}

// SetBalance sets the "balance" field.
func (m *WalletMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *WalletMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *WalletMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *WalletMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *WalletMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *WalletMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[wallet.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WalletMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WalletMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WalletMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user != nil {
		fields = append(fields, wallet.FieldUserID)
	}
	if m.balance != nil {
		fields = append(fields, wallet.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldUserID:
		return m.UserID()
	case wallet.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldUserID:
		return m.OldUserID(ctx)
	case wallet.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wallet.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, wallet.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldUserID:
		m.ResetUserID()
		return nil
	case wallet.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, wallet.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, wallet.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	switch name {
	case wallet.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	switch name {
	case wallet.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	switch name {
	case wallet.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Wallet edge %s", name)
}
